import utils
import configODSImport
from prompt_generator import generatePromptTemplates
from track import Track
import os
from batch_loaders.random_walk import *
import sys
sys.path.append('./verbalizer/Prompt_generator2/')
from verbalizer.Prompt_generator2 import generatePrompt

"""
runs functions according to the tasks in configODS
prepares configs, metrics for original project by FrancisGosselin

Parameters:
None

Returns: 
None
"""

def main():
    configODS = configODSImport.getConfigODS()

    #to stuff like in original project
    from train import train
    #get configFile from original project
    config = utils.importFromJson('config.json')
    #configure loader according to original project
    loader_config = {
        "iir":0.8, 
        "inter_soft_r":0.0, 
        "intra_soft_r":0.0, 
        "negative_sampling_strategy": "ontologic_relation",
        "no_hard_negative_samples":False,
        "epoch_over_alignments": False,
        "A": 5,
        "batch_size":32, 
        "n_alignments_per_batch":4
    }

    #pre align all possible classes by cross products as candidates
    if (configODS.get('exportCrossProductAsAlignments') == True):
        #configure metric according to original project
        metrics_config={"results_files_path": "./result_alignments",
            "write_rdf": False,
            "write_tsv": False,
            "write_ranking": False,
            "hits":[1, 3, 5, 10], 
            "debug_files_path": "./debug"}
        
        #load ontologies
        name = "conference"
        t = Track(name, config, metrics_config=metrics_config)
        ontos = {onto.get_name() : onto for onto in t.ontologies}

        #get which ontology maps to which one
        for ontoName1, ontoName2 in t.toBeMatchedOntologies:
            onto1 = ontos.get(ontoName1)
            onto2 = ontos.get(ontoName2)
            if onto1 and onto2:
                crossProduct = [[onto1.get_name() + '#' + class1, onto2.get_name() + '#' + class2, 'no score'] for class1 in onto1.get_classes() for class2 in onto2.get_classes()]
                path = configODS.get('alignmentPath') + ontoName1 + '-' + ontoName2 + '.json'
                utils.saveToJson(crossProduct, path, messageText=f'exported crossProduct ({ontoName1} X {ontoName2}) to ')

    #export alignment candidates by original project
    if (configODS.get('exportAlignmentsToJson') == True):
        path = configODS.get('alignmentPath') + "conference" + '/alignments' + '.json'
        infer_walk_WALK = RandomWalkConfig(walk_type = 'randomWalk', saveTriplesToJson = False, strategy=WalkStrategy.ONTOLOGICAL_RELATIONS, n_branches=5)
        train(["conference"], pretrained=config["General"]["model"], saveAlignmentsToJson = True, alignmentsPath = path, test_size=1.0, consider_train_set=False, loader_config=loader_config, train_walks=infer_walk_WALK, inference_walks=infer_walk_WALK)
        print(f"exported alignments to '{path}'")
    
    #run randomWalk Algorithm
    if configODS.get('runRandomWalkAlgorithm'):
        infer_walk_WALK = RandomWalkConfig(walk_type = 'randomWalk', strategy=WalkStrategy.ONTOLOGICAL_RELATIONS, n_branches=5)
        if ontos:
            for ontoName in ontos.keys():
                onto = ontos.get(ontoName)
                triples = {}
                for class1 in onto.get_classes():
                    triples.update(RandomWalk(onto, class1, infer_walk_WALK).triples)
                path = configODS.get('triplesPath') + "triples_randomWalk_" + onto.get_name() + '.json'
                utils.saveToJson(triples, path, f'exported random walk triples of {onto.get_name()} to')
    #run randomTree Algorithm
    if configODS.get('runRandomTreeAlgorithm'):
        randomTreeConfig = configODS.get('randomTreeConfig')
        if ontos and randomTreeConfig:
            for ontoName in ontos.keys():
                onto = ontos.get(ontoName)
                triples = {}
                for class1 in onto.get_classes():
                    tree = doRandomTree(onto, class1, randomTreeConfig)
                    if tree != None:
                        triplesOfClass1 = []
                        for classA in tree.keys():
                            for relation, classB in tree.get(classA):
                                classA = classA.replace('_', ' ')
                                relation = relation.replace('_', ' ')
                                classB = classB.replace('_', ' ')
                                triplesOfClass1.append([classA, relation, classB])
                        triples[onto.get_name() + '#' + class1] = triplesOfClass1
                path = configODS.get('triplesPath') + "triples_randomTree_" + onto.get_name() + '.json'
                utils.saveToJson(triples, path, f'exported random tree triples of {onto.get_name()} to')
                    

    
    #export triples generated by the random walk algorithm
    if configODS.get('exportRandomWalkTriples') == True:
        infer_walk_WALK = RandomWalkConfig(walk_type = 'randomWalk', saveTriplesToJson = True, triplesPath = configODS.get('walkTriplesPath'), strategy=WalkStrategy.ONTOLOGICAL_RELATIONS, n_branches=5)
        train(["conference"], pretrained=config["General"]["model"], saveAlignmentsToJson = False, test_size=1.0, consider_train_set=False, loader_config=loader_config, train_walks=infer_walk_WALK, inference_walks=infer_walk_WALK)
        print(f"exported random walk triples to '{configODS.get('walkTriplesPath')}'")

    #export triples generated by the random tree algorithm
    if configODS.get('exportRandomTreeTriples') == True:
        infer_walk_TREE = RandomWalkConfig(walk_type = 'randomTree', saveTriplesToJson = True, triplesPath = configODS.get('treeTriplesPath'), strategy=WalkStrategy.ONTOLOGICAL_RELATIONS, n_branches=5)
        train(["conference"], pretrained=config["General"]["model"], saveAlignmentsToJson = False, test_size=1.0, consider_train_set=False, loader_config=loader_config, train_walks=infer_walk_TREE, inference_walks=infer_walk_TREE)
        print(f"exported random tree triples to '{configODS.get('treeTriplesPath')}'")
    
    #export prompts generated by generatePromptTemplates.py with alignment candidates and context triples extracted by random algorithms
    #promptVersions: list of integers indicating which prompt versions to use
    promptVersion = configODS.get('promptsFoExportToJson')
    if promptVersion:
        #print(f"promptVersions: {promptVersion}")
        for i in promptVersion:
            for file_path in os.listdir(configODS.get('alignmentPath')):
                #print(f"processing '{file_path}'")
                if file_path.endswith('.json'):
                    alignmentFilePath = configODS.get('alignmentPath') + file_path
                    if configODS.get('exportWalkPromptsToJson'):
                        if not os.path.exists(configODS.get('promptsPath') + f"walkPromptVersion{i}/"):
                            os.mkdir(configODS.get('promptsPath') + f"walkPromptVersion{i}/")
                        contextPaths = [configODS.get('triplesVerbalizedPath') + 'verbalized_triples_randomWalk_' + ontoName + '.json' for ontoName in file_path.replace('.json', '').split('-')]
                        promptList = generatePromptTemplates.getPrompt(alignmentFilePath, contextPaths, promptVersion = i, promptCounter = -1, skipIfNoContext = True)
                        utils.saveToJson(promptList, configODS.get('promptsPath') + f"walkPromptVersion{i}/"+ file_path, f"exported 'walkPromptVersion{i}' with alignments '{alignmentFilePath} and context '{contextPaths}' to")
                    if configODS.get('exportTreePromptsToJson'):
                        if not os.path.exists(configODS.get('promptsPath') + f"treePromptVersion{i}/"):
                            os.mkdir(configODS.get('promptsPath') + f"treePromptVersion{i}/")
                        contextPaths = [configODS.get('triplesVerbalizedPath') + 'verbalized_triples_randomTree_' + ontoName + '.json' for ontoName in file_path.replace('.json', '').split('-')]
                        promptList = generatePromptTemplates.getPrompt(alignmentFilePath, contextPaths, promptVersion = i, promptCounter = -1, skipIfNoContext = True)
                        utils.saveToJson(promptList, configODS.get('promptsPath') + f"treePromptVersion{i}/"+ file_path, f"exported 'treePromptVersion{i}' with alignments '{alignmentFilePath} and context '{contextPaths}' to")
    if configODS.get('verbalizeAvailableTriples'):
        for file_path in os.listdir(configODS.get('triplesPath')):
            if file_path.endswith('.json'):
                tripleFilePath = configODS.get('triplesPath') + file_path
                tripleVerbalizedFilePath = configODS.get('triplesVerbalizedPath') + 'verbalized_' + file_path
                generatePrompt.verbaliseFile(tripleFilePath, tripleVerbalizedFilePath)

main()
